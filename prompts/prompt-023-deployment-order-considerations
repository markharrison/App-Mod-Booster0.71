## Infrastructure vs Application Deployment Separation

There are two distinct deployment phases, each with its own automated PowerShell script.

### Phase 1: Infrastructure Deployment

Run the infrastructure deployment script:

    .\deploy-infra\deploy.ps1 -ResourceGroup "rg-yourapp-YYYYMMDD" -Location "uksouth"

Important: Always use a unique resource group name (include date/time suffix). Reusing resource groups with partially deployed resources can cause ARM caching issues, particularly with Log Analytics Workspace references that result in "Could not retrieve the Log Analytics workspace from ARM" errors.

This script handles everything automatically: Azure CLI validation, credential retrieval, resource group creation, Bicep deployment, SQL Server configuration, firewall rules, database schema import, stored procedures, managed identity permissions, and App Service settings.

**Critical: The infrastructure deployment script MUST configure the App Service with:**
- `ConnectionStrings__DefaultConnection` - The SQL connection string with Managed Identity authentication
- `AZURE_CLIENT_ID` - The user-assigned managed identity client ID

Without these settings, the application will fail to connect to the database with errors like "System.InvalidOperationException: A relational store has been configured without specifying either the DbConnection or connection string to use."

At the end, the script saves a deployment context file (.deployment-context.json) containing all the resource names and configuration values needed for the next phase.

### Phase 2: Application Deployment

After infrastructure deployment completes, run the application deployment script with no parameters:

    .\deploy-app\deploy.ps1

The script automatically reads the deployment context file created by the infrastructure script, so you don't need to specify the resource group or web app name. It builds the .NET application, creates a deployment package, and deploys to Azure App Service.

### Seamless Deployment Flow

The two scripts are designed to work together without manual parameter entry between them. The deployment context file passes resource names and configuration values from infrastructure deployment to application deployment automatically.

### Known Issues and Workarounds

1. VS Code integrated terminal may use cached PATH: If sqlcmd produces errors about unrecognized arguments, the terminal may be using the legacy ODBC sqlcmd instead of modern go-sqlcmd. Either restart VS Code or run from a standalone PowerShell terminal.

2. PowerShell argument parsing: The --authentication-method argument must be quoted in PowerShell scripts to prevent parsing errors.

3. Resource group reuse: Always use fresh resource group names. If a deployment fails partway through, delete the resource group before retrying.

### Bicep Best Practices

Use uniqueString(resourceGroup().id) to generate deterministic unique names for resources. Never use timestamps like utcNow() in variable declarations as this is not allowed in Bicep.

Key considerations for Bicep templates:

**Naming and References:**

- All resource names should be lowercase to comply with Azure naming requirements
- Use symbolic resource references instead of string-based references (e.g., `appService.outputs.webAppId` not resource ID strings)
- Do NOT use the `name` property on module declarations - use the symbolic name directly

**Parameters:**

- Use `.bicepparam` files instead of `parameters.json` for better type safety and IDE support
- Example: `main.bicepparam` with `using './main.bicep'` at the top
- Add descriptions to all parameters using `@description()` decorator

**Conditional Resources:**

- Conditional module outputs must use null-safe operators (?. and ??) to prevent errors when optional modules are not deployed
- Example: `output openAIEndpoint string = genAI.?outputs.?openAIEndpoint ?? ''`

**Functions and Variables:**

- The utcNow() function can ONLY be used as a parameter default value, never in variable declarations
- Incorrect: `var timestamp = utcNow('yyyyMMddHHmm')` - causes BCP065 error
- Correct: `param timestamp string = utcNow('yyyyMMddHHmm')` - use as parameter default
- Use `uniqueString(resourceGroup().id)` for deterministic unique names

**Avoiding Circular Dependencies (BCP080):**

- Monitoring resources (Application Insights) and App Service can create circular dependencies if not structured correctly
- Problem: App Service needs `appInsightsConnectionString` from Monitoring, but Monitoring needs `appServiceName` for diagnostics
- Solution: Split the deployment into phases:
  1. Deploy Monitoring module first WITHOUT App Service diagnostics (pass empty string for appServiceName)
  2. Deploy App Service second, referencing the Application Insights connection string
  3. Deploy App Service diagnostics as a separate module AFTER App Service is created
- Create a separate `app-service-diagnostics.bicep` module that takes `appServiceName` and `logAnalyticsWorkspaceId` as parameters
- Make the `appServiceName` parameter optional in the monitoring module with a default empty string
- Use conditional resource deployment: `resource appService ... = if (!empty(appServiceName)) { ... }`

**Diagnostics:**

- Do not configure diagnostic settings at the SQL Server level as categories like SQLSecurityAuditEvents are not supported - only configure diagnostics at the database level
- App Service diagnostics should be deployed in a separate module after the App Service exists to avoid circular dependencies
